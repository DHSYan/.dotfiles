/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var view = require('@codemirror/view');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const DEFAULT_SETTINGS = {
    numberCursors: 1,
    selectionMode: "full",
    displayCharCount: true,
    displayPatternOption: "clt",
    displayPattern: "",
    cursorSeparatorOption: "slash",
    cursorSeparator: "",
    rangeSeparatorOption: "arrow",
    rangeSeparator: "",
    displayCursorLineCount: true,
    displayTotalLines: true,
    displayCursorLines: false,
    cursorLinePatternOption: "square",
    cursorLinePattern: "",
    statusBarPadding: false,
    paddingStepOption: "medium",
    paddingStep: 9,
    wordyDisplay: false,
    fuzzyAmount: "strictpercent",
    excludeFrontmatter: false,
    frontmatterString: "frontmatter",
    frontmatterStringCustom: "",
};
const MIDDLEPATTERN = /^.*(ln|ch).*?ct.*?(ln|ch).*/i;
const BEGINPATTERN = /^.*ct.*((ln|ch).*?(ln|ch).*)/i;
const ENDPATTERN = /(.*(ln|ch).*?(ln|ch)).*?ct.*$/i;
const FRONTMATTER = /^\s*?---\n+?[\s\S]*?\n---/;
const MULTCURSORS = "{} cursors";
const SELECTTEXTDISPLAY = `{} selected`;
const SELECTLINEDISPLAY = `{} lines`;
const SELECTMULT = ` ({} / {})`;
const SELECTSINGLE = ` ({})`;
// preamble, metadata, frontmatter
// optional names, optional include
// top, near top, middle, near bottom, bottom
// 0-19, 20-39, 40-59, 60-79, 80-100
const LOWRANGEWORDS = new Map([
    [0, "top"],
    [20, "near top"],
    [40, "middle"],
    [60, "near bottom"],
    [80, "bottom"],
    [100, "bottom"],
]);
// top, middle, bottom
// 0-32, 33-65, 66-99(/100)
const HIGHRANGEWORDS = new Map([
    [0, "top"],
    [33, "middle"],
    [66, "bottom"],
    [99, "bottom"],
    [100, "bottom"],
]);
// top, %%, bottom
// 0, 1-99, 100
const HARDPERCENTWORDS = new Map([
    [0, "top"],
    [100, "bottom"],
]);
const CURSORSEPERATOR = new Map([
    ["slash", "/"],
    ["pipe", "|"],
    ["tilde", "~"],
    ["ampersand", "&"],
]);
const RANGESEPERATOR = new Map([
    ["arrow", "→"],
    ["dash", "-"],
    ["tilde", "~"],
]);
const PADDINGSTEP = new Map([
    ["low", 6],
    ["medium", 12],
    ["high", 24],
]);
const DISPLAYPATTERN = new Map([
    ["clt", "ch:ln/ct"],
    ["lct", "ln:ch/ct"],
    ["clt2", "ch ln-ct"],
    ["clts", "ch ln ct"],
    ["lcts", "ln ch ct"],
]);

function format(raw, ...args) {
    for (let arg of args) {
        raw = raw.replace("{}", arg.toString());
    }
    return raw;
}
function closest(val, to) {
    return Math.floor(val / to) * to;
}
function showElem(elem) {
    elem.removeAttribute("style");
}
function hideElem(elem) {
    elem.setAttribute("style", "display:none;");
}

class SettingElement {
    constructor(container, title, plugin, name, override = null) {
        this.name = name;
        this.plugin = plugin;
        this.override = override;
        this.children = [];
        this.element = container.createDiv();
        this.element.createEl("h3", { text: title });
    }
    resetComponent() {
        const value = DEFAULT_SETTINGS[this.name];
        console.log(`resetting ${this.name}: ${value}`);
        let component = this.setting.components[0];
        component.setValue(value);
        this.plugin.settings[this.name] = value;
        if (this.warning != null)
            this.warning.setText("");
    }
    resetSetting() {
        let value = this.override ? this.override : DEFAULT_SETTINGS[this.name];
        new obsidian.Setting(this.element)
            .setName(`Reset to default value of '${value}'`)
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.resetComponent();
            yield this.plugin.saveSettings();
        })));
    }
    createWarning() {
        return this.element.createEl("p", { text: "", attr: { style: "color:red" } });
    }
    basicOnChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            if (this.plugin.settings[this.name] != value) {
                console.log(`changing ${this.name}: ${value}`);
            }
            if (typeof DEFAULT_SETTINGS[this.name] === "boolean") {
                this.plugin.settings[this.name] = value;
            }
            else {
                this.plugin.settings[this.name] = value === null || value === void 0 ? void 0 : value.trim();
            }
            yield this.plugin.saveSettings();
        });
    }
    numberOnChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            let parsedValue = parseInt(value);
            if (!isNaN(parsedValue)) {
                if (this.plugin.settings[this.name] != value) {
                    console.log(`changing ${this.name}: ${value}`);
                }
                this.warning.setText("");
                this.plugin.settings[this.name] = parsedValue;
                yield this.plugin.saveSettings();
                this.error = false;
            }
            else {
                console.log(`unable to update ${this.name}, `, `unable to parse new value into integer: ${value}`);
                this.warning.setText(`"${value}" is not a full number, unable to save.`);
                this.error = true;
            }
        });
    }
    show() {
        if (this.element)
            showElem(this.element);
        if (this.warning)
            showElem(this.warning);
        this.showChildren();
    }
    showChildren() {
        this.children.forEach(c => c.show());
    }
    hide() {
        if (this.element)
            hideElem(this.element);
        if (this.warning)
            hideElem(this.warning);
        this.hideChildren();
    }
    hideChildren() {
        this.children.forEach(c => c.hide());
    }
}
class SettingElementCustom extends SettingElement {
    customOnChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            if (this.plugin.settings[this.customName] != value) {
                console.log(`changing ${this.customName}: ${value}`);
            }
            if (typeof DEFAULT_SETTINGS[this.customName] === "boolean") {
                this.plugin.settings[this.customName] = value;
            }
            else {
                this.plugin.settings[this.customName] = value === null || value === void 0 ? void 0 : value.trim();
            }
            yield this.plugin.saveSettings();
        });
    }
    toggleCustom() {
        const isCustom = this.plugin.settings[this.name] == "custom";
        const elem = this.custom.settingEl;
        isCustom ? showElem(elem) : hideElem(elem);
    }
    basicOnChange() {
        const _super = Object.create(null, {
            basicOnChange: { get: () => super.basicOnChange }
        });
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield _super.basicOnChange.call(this)(value);
            this.toggleCustom();
        });
    }
}
class NumberCursors extends SettingElement {
    constructor(container, plugin) {
        super(container, "# of Cursors", plugin, "numberCursors");
        this.setting = new obsidian.Setting(this.element)
            .setName('Number of cursor positions that will display \
          in the status bar before switching to "N cursors".')
            .addText((text) => {
            var _a, _b;
            text
                .setValue((_b = (_a = this.plugin.settings) === null || _a === void 0 ? void 0 : _a.numberCursors) === null || _b === void 0 ? void 0 : _b.toString())
                .onChange(this.onChange());
        });
        this.warning = this.createWarning();
        this.resetSetting();
    }
    onChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield this.numberOnChange()(value);
            if (!this.error)
                this.toggleChildren();
        });
    }
    showChildren() {
        if (this.plugin.settings.numberCursors != 1) {
            super.showChildren();
        }
    }
    toggleChildren() {
        const num = this.plugin.settings.numberCursors;
        num == 1 ? super.hideChildren() : super.showChildren();
    }
}
class SelectionMode extends SettingElement {
    constructor(container, plugin) {
        super(container, "Selection Mode", plugin, "selectionMode", "Full Selection");
        this.setting = new obsidian.Setting(this.element)
            .setName("Display just the beginning, \
        just the end, or the full range of a selection.")
            .addDropdown((cb) => {
            cb
                .addOption("full", "Full Selection")
                .addOption("begin", "Beginning")
                .addOption("end", "End")
                .setValue(this.plugin.settings.selectionMode
                || DEFAULT_SETTINGS.selectionMode)
                .onChange(this.onChange());
        });
        this.resetSetting();
    }
    onChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield this.basicOnChange()(value);
            this.toggleChildren();
        });
    }
    showChildren() {
        if (this.plugin.settings.selectionMode == "full") {
            super.showChildren();
        }
    }
    toggleChildren() {
        const mode = this.plugin.settings.selectionMode;
        mode == "full" ? super.showChildren() : super.hideChildren();
    }
}
class DisplayCharCount extends SettingElement {
    constructor(container, plugin) {
        super(container, "Display Character Count", plugin, "displayCharCount");
        this.setting = new obsidian.Setting(this.element)
            .setName("Display the total number of characters selected.")
            .addToggle((cb) => {
            cb
                .setValue(this.plugin.settings.displayCharCount != null
                ? this.plugin.settings.displayCharCount
                : DEFAULT_SETTINGS.displayCharCount)
                .onChange(this.basicOnChange());
        });
        this.resetSetting();
    }
}
class DisplayTotalLineCount extends SettingElement {
    constructor(container, plugin) {
        super(container, "Display Total Line Count", plugin, "displayTotalLines");
        this.setting = new obsidian.Setting(this.element)
            .setName("Display the total number of lines selected.")
            .addToggle((cb) => {
            cb
                .setValue(this.plugin.settings.displayTotalLines != null
                ? this.plugin.settings.displayTotalLines
                : DEFAULT_SETTINGS.displayTotalLines)
                .onChange(this.basicOnChange());
        });
        this.resetSetting();
    }
}
class DisplayPattern extends SettingElementCustom {
    constructor(container, plugin) {
        super(container, "Individual Cursor Pattern", plugin, "displayPatternOption", "ch:ln/ct");
        this.customName = "displayPattern";
        this.setting = new obsidian.Setting(this.element)
            .setName("Pattern to display location information for each cursor.")
            .setDesc("`ch` is the column the cursor is at in the current line, \
        `ln` is the current line number, \
        `ct` is the total line numbers in the file (count).")
            .addDropdown((cb) => {
            cb
                .addOption("clt", "ch:ln/ct")
                .addOption("lct", "ln:ch/ct")
                .addOption("clt2", "ch ln-ct")
                .addOption("clts", "ch ln ct")
                .addOption("lcts", "ln ch ct")
                .addOption("custom", "custom")
                .setValue(this.plugin.settings.displayPatternOption
                || DEFAULT_SETTINGS.displayPatternOption)
                .onChange(this.basicOnChange());
        });
        this.custom = new obsidian.Setting(this.element)
            .setName("Custom pattern for display")
            .setDesc("If `ct` is the first or last of the three values, \
        it will be removed when displaying a range.")
            .addText((text) => {
            text
                .setValue(this.plugin.settings.displayPattern)
                .onChange(this.customOnChange());
        });
        this.resetSetting();
        this.toggleCustom();
    }
}
class CursorSeparator extends SettingElementCustom {
    constructor(container, plugin) {
        super(container, "Cursor Separator", plugin, "cursorSeparatorOption", "slash `/`");
        this.customName = "cursorSeparator";
        this.setting = new obsidian.Setting(this.element)
            .setName("String to seperate multiple curor locations when \
        `# of Cursors` is greater than 1. Selecting `custom` \
        will let you type out your own")
            .addDropdown((cb) => {
            cb
                .addOption("slash", "slash `/`")
                .addOption("pipe", "pipe `|`")
                .addOption("tilde", "tilde `~`")
                .addOption("ampersand", "ampersand `&`")
                .addOption("custom", "custom")
                .setValue(this.plugin.settings.cursorSeparatorOption
                || DEFAULT_SETTINGS.cursorSeparatorOption)
                .onChange(this.basicOnChange());
        });
        this.custom = new obsidian.Setting(this.element)
            .setName("String will be padded by a space on each side. \
        Consecutive whitespace is squashed to 1 space (per HTML rules). \
        For example: '/' will be displayed as ' / '")
            .addText((text) => {
            text
                .setValue(this.plugin.settings.cursorSeparator)
                .onChange(this.customOnChange());
        });
        this.resetSetting();
        this.toggleCustom();
    }
}
class RangeSeparator extends SettingElementCustom {
    constructor(container, plugin) {
        super(container, "Range Separator", plugin, "rangeSeparatorOption", "arrow '→'");
        this.customName = "rangeSeparator";
        this.setting = new obsidian.Setting(this.element)
            .setName("String to seperate the beginning and end of a selection \
          when `Selection Mode` is set to `Full Selection`. \
          Selecting `custom` will let you type out your own")
            .addDropdown((cb) => {
            cb
                .addOption("arrow", "arrow '→'")
                .addOption("dash", "dash `-`")
                .addOption("tilde", "tilde `~`")
                .addOption("custom", "custom")
                .setValue(this.plugin.settings.rangeSeparatorOption
                || DEFAULT_SETTINGS.rangeSeparatorOption)
                .onChange(this.basicOnChange());
        });
        this.custom = new obsidian.Setting(this.element)
            .setName("String will NOT be padded by a space on each side. \
          Consecutive whitespace is squashed to 1 space (per HTML rules) \
          For example: '->' will be displayed as '2->3' and ' -> ' will \
          be displayed as '2 -> 3'")
            .addText((text) => {
            text
                .setValue(this.plugin.settings.rangeSeparator)
                .onChange(this.customOnChange());
        });
        this.resetSetting();
        this.toggleCustom();
    }
}
class DisplayCursorLines extends SettingElement {
    constructor(container, plugin) {
        super(container, "Display Cursor Line Count", plugin, "displayCursorLines");
        this.setting = new obsidian.Setting(this.element)
            .setName("Display the number of lines selected by each cursor.")
            .addToggle((cb) => {
            cb
                .setValue(this.plugin.settings.displayCursorLines != null
                ? this.plugin.settings.displayCursorLines
                : DEFAULT_SETTINGS.displayCursorLines)
                .onChange(this.onChange());
        });
        this.resetSetting();
    }
    onChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield this.basicOnChange()(value);
            this.toggleChildren();
        });
    }
    showChildren() {
        if (this.plugin.settings.displayCursorLines) {
            super.showChildren();
        }
    }
    toggleChildren() {
        const display = this.plugin.settings.displayCursorLines;
        display ? super.showChildren() : super.hideChildren();
    }
}
class CursorLinePattern extends SettingElementCustom {
    constructor(container, plugin) {
        super(container, "Cursor Line Pattern", plugin, "cursorLinePatternOption", "[lc]");
        this.customName = "cursorLinePattern";
        this.setting = new obsidian.Setting(this.element)
            .setName("Pattern to display number of highlighted lines for each cursor.")
            .addDropdown((cb) => {
            cb
                .addOption("square", "[lc]")
                .addOption("curly", "{lc}")
                .addOption("parens", "(lc)")
                .addOption("pointy", "<lc>")
                .addOption("custom", "custom")
                .setValue(this.plugin.settings.cursorLinePatternOption
                || DEFAULT_SETTINGS.cursorLinePatternOption)
                .onChange(this.basicOnChange());
        });
        this.custom = new obsidian.Setting(this.element)
            .setName("`lc` is the line count and will not be displayed if only one line \
          is selected or 'Display Cursor Line Count' setting is `false`. \
          Leading and trailing whitespace is trimmed.")
            .addText((text) => {
            text
                .setValue(this.plugin.settings.cursorLinePattern)
                .onChange(this.customOnChange());
        });
        this.resetSetting();
        this.toggleCustom();
    }
}
class StatusBarPadding extends SettingElement {
    constructor(container, plugin) {
        super(container, "Pad Status Bar", plugin, "statusBarPadding");
        this.setting = new obsidian.Setting(this.element)
            .setName("Add padding to lessen the amount the status bar shifts")
            .addToggle((cb) => {
            cb
                .setValue(this.plugin.settings.statusBarPadding != null
                ? this.plugin.settings.statusBarPadding
                : DEFAULT_SETTINGS.statusBarPadding)
                .onChange(this.onChange());
        });
        this.resetSetting();
    }
    onChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield this.basicOnChange()(value);
            this.toggleChildren();
        });
    }
    showChildren() {
        if (this.plugin.settings.statusBarPadding) {
            super.showChildren();
        }
    }
    toggleChildren() {
        const display = this.plugin.settings.statusBarPadding;
        display ? super.showChildren() : super.hideChildren();
    }
}
class PaddingStep extends SettingElementCustom {
    constructor(container, plugin) {
        super(container, "Padding Width", plugin, "paddingStepOption", "low `6px`");
        this.customName = "paddingStep";
        this.setting = new obsidian.Setting(this.element)
            .setName("Amount the status bar will round to when padding.")
            .setDesc("For example, with the default value of '12' the status bar \
        could be set to a width of 60 if the contents width is 55.")
            .addDropdown((cb) => {
            cb
                .addOption("low", "low `6px`")
                .addOption("medium", "medium `12px`")
                .addOption("high", "high `24px`")
                .addOption("custom", "custom")
                .setValue(this.plugin.settings.paddingStepOption
                || DEFAULT_SETTINGS.paddingStepOption)
                .onChange(this.basicOnChange());
        });
        this.custom = new obsidian.Setting(this.element)
            .setName("Multiples of 3 work best, though any positive value will do.")
            .setDesc("A cursor with just the head is around 70px. \
        A single selection with head and anchor plus totals is around 250px. \
        3 selections like the above with individual line counts is around 500px.")
            .addText((text) => {
            var _a, _b;
            text
                .setValue((_b = (_a = this.plugin.settings) === null || _a === void 0 ? void 0 : _a.paddingStep) === null || _b === void 0 ? void 0 : _b.toString())
                .onChange(this.numberOnChange());
        });
        this.warning = this.createWarning();
        this.resetSetting();
        this.toggleCustom();
    }
}
class WordyDisplay extends SettingElement {
    constructor(container, plugin) {
        super(container, "Display as Percent", plugin, "wordyDisplay");
        this.percents = [];
        this.rowcol = [];
        this.setting = new obsidian.Setting(this.element)
            .setName("Display percent thru the document instead of line number")
            .addToggle((cb) => {
            cb
                .setValue(this.plugin.settings.wordyDisplay != null
                ? this.plugin.settings.wordyDisplay
                : DEFAULT_SETTINGS.wordyDisplay)
                .onChange(this.onChange());
        });
        this.resetSetting();
    }
    onChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield this.basicOnChange()(value);
            this.showSettings();
        });
    }
    showSettings() {
        if (this.plugin.settings.wordyDisplay) {
            this.percents.forEach(s => s.show());
            this.rowcol.forEach(s => s.hide());
        }
        else {
            this.percents.forEach(s => s.hide());
            this.rowcol.forEach(s => s.show());
        }
    }
}
class FuzzyAmount extends SettingElement {
    constructor(container, plugin) {
        super(container, "Percentage Mode", plugin, "fuzzyAmount", "Strict Percentages");
        this.setting = new obsidian.Setting(this.element)
            .setName("How many words vs percent numbers to display.")
            .setDesc("\
        'Strict Percentages' will say at the top and bottom, and then percentages from 1% to 99%. \
        'Low Fuzzy Percentages' will say at the top and bottom for the first and last 10%, percentages for the rest of the document. \
        'High Fuzzy Percentages' will say at the top and bottom for the first and last 20%, percentages for the rest of the document. \
        'Only Percentages' shows percentages throughout the document, no words are used. \
        'Very Wordy' only uses words, splits the document into 5ths. \
        'Barely Wordy' only uses words, splits the document into 3rds. \
        ")
            .addDropdown((cb) => {
            cb
                .addOption("strictpercent", "Strict Percentages")
                .addOption("lowfuzzypercent", "Low Fuzzy Percentages")
                .addOption("highfuzzypercent", "High Fuzzy Percentages")
                .addOption("onlypercent", "Only Percentages")
                .addOption("verywordy", "Very Wordy")
                .addOption("littewordy", "Barely Wordy")
                .setValue(this.plugin.settings.fuzzyAmount
                || DEFAULT_SETTINGS.fuzzyAmount)
                .onChange(this.basicOnChange());
        });
        this.resetSetting();
    }
}
class ExcludeFrontmatter extends SettingElement {
    constructor(container, plugin) {
        super(container, "Exclude Frontmatter", plugin, "excludeFrontmatter");
        this.setting = new obsidian.Setting(this.element)
            .setName("Exclude the frontmatter as part of the document percentage")
            .addToggle((cb) => {
            cb
                .setValue(this.plugin.settings.excludeFrontmatter != null
                ? this.plugin.settings.excludeFrontmatter
                : DEFAULT_SETTINGS.excludeFrontmatter)
                .onChange(this.onChange());
        });
        this.resetSetting();
    }
    onChange() {
        return (value) => __awaiter(this, void 0, void 0, function* () {
            yield this.basicOnChange()(value);
            this.toggleChildren();
        });
    }
    showChildren() {
        if (this.plugin.settings.excludeFrontmatter) {
            super.showChildren();
        }
    }
    toggleChildren() {
        const display = this.plugin.settings.excludeFrontmatter;
        display ? super.showChildren() : super.hideChildren();
    }
}
class FrontmatterString extends SettingElementCustom {
    constructor(container, plugin) {
        super(container, "Frontmatter Phrase", plugin, "frontmatterString");
        this.customName = "frontmatterStringCustom";
        this.setting = new obsidian.Setting(this.element)
            .setName("What to call the frontmatter when cursor is inside it")
            .addDropdown((cb) => {
            cb
                .addOption("frontmatter", "frontmatter")
                .addOption("metadata", "metadata")
                .addOption("preamble", "preamble")
                .addOption("custom", "custom")
                .setValue(this.plugin.settings.frontmatterString
                || DEFAULT_SETTINGS.frontmatterString)
                .onChange(this.basicOnChange());
        });
        this.custom = new obsidian.Setting(this.element)
            .setName("If you don't like the options provided, \
        you can set the frontmatter to whaterver \
        you want with this.")
            .addText((text) => {
            var _a;
            text
                .setValue((_a = this.plugin.settings) === null || _a === void 0 ? void 0 : _a.frontmatterStringCustom)
                .onChange(this.customOnChange());
        });
        this.resetSetting();
        this.toggleCustom();
    }
}

class CursorLocationSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createDiv().createEl("h2", { text: "Cursor Information" });
        const NumberCursors$1 = new NumberCursors(containerEl, this.plugin);
        const CursorSeparator$1 = new CursorSeparator(containerEl, this.plugin);
        NumberCursors$1.children.push(CursorSeparator$1);
        const SelectionMode$1 = new SelectionMode(containerEl, this.plugin);
        const RangeSeparator$1 = new RangeSeparator(containerEl, this.plugin);
        SelectionMode$1.children.push(RangeSeparator$1);
        const WordyDisplay$1 = new WordyDisplay(containerEl, this.plugin);
        // Add a Dropdown "Pattern" option, maybe switch Display Pattern
        // As part of the "custom" option, show the other options
        const DisplayPattern$1 = new DisplayPattern(containerEl, this.plugin);
        const DisplayCursorLines$1 = new DisplayCursorLines(containerEl, this.plugin);
        const CursorLinePattern$1 = new CursorLinePattern(containerEl, this.plugin);
        DisplayCursorLines$1.children.push(CursorLinePattern$1);
        const FuzzyAmount$1 = new FuzzyAmount(containerEl, this.plugin);
        const ExcludeFrontmatter$1 = new ExcludeFrontmatter(containerEl, this.plugin);
        const FrontmatterString$1 = new FrontmatterString(containerEl, this.plugin);
        ExcludeFrontmatter$1.children.push(FrontmatterString$1);
        const StatusBarPadding$1 = new StatusBarPadding(containerEl, this.plugin);
        const PaddingStep$1 = new PaddingStep(containerEl, this.plugin);
        StatusBarPadding$1.children.push(PaddingStep$1);
        const DisplayCharCount$1 = new DisplayCharCount(containerEl, this.plugin);
        const DisplayTotalLineCount$1 = new DisplayTotalLineCount(containerEl, this.plugin);
        WordyDisplay$1.percents.push(FuzzyAmount$1);
        WordyDisplay$1.percents.push(ExcludeFrontmatter$1);
        WordyDisplay$1.rowcol.push(DisplayPattern$1);
        WordyDisplay$1.rowcol.push(DisplayCursorLines$1);
        ExcludeFrontmatter$1.toggleChildren();
        NumberCursors$1.toggleChildren();
        SelectionMode$1.toggleChildren();
        DisplayCursorLines$1.toggleChildren();
        StatusBarPadding$1.toggleChildren();
        WordyDisplay$1.showSettings();
        const cursorLocationSettings = [
            NumberCursors$1,
            SelectionMode$1,
            DisplayCharCount$1,
            DisplayTotalLineCount$1,
            DisplayPattern$1,
            CursorSeparator$1,
            RangeSeparator$1,
            DisplayCursorLines$1,
            CursorLinePattern$1,
            StatusBarPadding$1,
            PaddingStep$1,
            WordyDisplay$1,
            FuzzyAmount$1,
            ExcludeFrontmatter$1,
            FrontmatterString$1,
        ];
        containerEl.createDiv().createEl("h2", { text: "Reset All Settings" });
        let resetAllEl = containerEl.createDiv();
        new obsidian.Setting(resetAllEl)
            .setName("Reset all settings to default values.")
            .addButton((cb) => cb.setButtonText("Reset").onClick(() => __awaiter(this, void 0, void 0, function* () {
            console.log("resetting all values to their defaults");
            cursorLocationSettings.forEach(setting => setting.resetComponent());
            yield this.plugin.saveSettings();
            NumberCursors$1.toggleChildren();
            SelectionMode$1.toggleChildren();
            DisplayCursorLines$1.toggleChildren();
            StatusBarPadding$1.toggleChildren();
            WordyDisplay$1.showSettings();
        })));
    }
}

function generateSelections(doc, ranges, frontmatter = null) {
    let selections = new Selections();
    ranges.forEach((range) => {
        selections.addCursor(new CursorData(range, doc, frontmatter));
    });
    return selections;
}
class Selections {
    constructor() {
        this.lines = 0;
        this.chars = 0;
        this.cursors = [];
    }
    addCursor(cursor) {
        this.chars += cursor.highlightedChars;
        this.lines += cursor.highlightedLines;
        this.cursors.push(cursor);
    }
    totalDisplay(settings) {
        let totalsDisplay = "";
        let textDisplay;
        let lineDisplay;
        if (settings.displayCharCount) {
            textDisplay = format(SELECTTEXTDISPLAY, this.chars);
        }
        if (settings.displayTotalLines) {
            lineDisplay = format(SELECTLINEDISPLAY, this.lines);
        }
        if (settings.displayCharCount && settings.displayTotalLines) {
            totalsDisplay = format(SELECTMULT, textDisplay, lineDisplay);
        }
        else if (settings.displayCharCount) {
            totalsDisplay = format(SELECTSINGLE, textDisplay);
        }
        else if (settings.displayTotalLines) {
            totalsDisplay = format(SELECTSINGLE, lineDisplay);
        }
        return totalsDisplay;
    }
}
class CursorData {
    constructor(range, doc, frontmatter) {
        this.docLineCount = doc.lines;
        this.docCharCount = doc.length;
        const aLine = doc.lineAt(range.anchor);
        this.anchorLine = aLine.number;
        this.anchorChar = range.anchor - aLine.from;
        const hLine = doc.lineAt(range.head);
        this.headLine = hLine.number;
        this.headChar = range.head - hLine.from;
        this.highlightedChars = range.to - range.from;
        this.highlightedLines = Math.abs(this.anchorLine - this.headLine) + 1;
        this.frontmatter = frontmatter;
    }
    partialString(value, skipTotal = false) {
        if (!skipTotal || MIDDLEPATTERN.test(value)) {
            value = value.replace("ct", this.docLineCount.toString());
        }
        else if (BEGINPATTERN.test(value)) {
            value = value.replace(BEGINPATTERN, "$1");
        }
        else if (ENDPATTERN.test(value)) {
            value = value.replace(ENDPATTERN, "$1");
        }
        return value;
    }
    anchorString(value, skipTotal = false) {
        return this.partialString(value, skipTotal)
            .replace("ch", this.anchorChar.toString())
            .replace("ln", this.anchorLine.toString());
    }
    headString(value, skipTotal = false) {
        return this.partialString(value, skipTotal)
            .replace("ch", this.headChar.toString())
            .replace("ln", this.headLine.toString());
    }
    percent(line) {
        let total = (this.docLineCount - 1);
        line -= 1;
        if (this.frontmatter === null) {
            const res = Math.round(((line / total) + Number.EPSILON) * 100);
            return res;
        }
        line -= this.frontmatter;
        total -= this.frontmatter;
        const res = Math.round(((line / total) + Number.EPSILON) * 100);
        return res;
    }
    wordyString(curLine, fuzzyAmount, frontmatterString) {
        if (this.frontmatter != null && this.frontmatter >= curLine) {
            return frontmatterString;
        }
        const pct = this.percent(curLine);
        switch (fuzzyAmount) {
            case "verywordy":
                return LOWRANGEWORDS.get(closest(pct, 20));
            case "littewordy":
                return HIGHRANGEWORDS.get(closest(pct, 33));
            case "strictpercent":
                if (pct == 0 || pct == 100) {
                    return HARDPERCENTWORDS.get(pct);
                }
                return `${pct}%`;
            case "lowfuzzypercent":
                if (pct <= 10)
                    return "top";
                if (pct >= 90)
                    return "bottom";
                return `${pct}%`;
            case "highfuzzypercent":
                if (pct <= 20)
                    return "top";
                if (pct >= 80)
                    return "bottom";
                return `${pct}%`;
            case "onlypercent":
                return `${pct}%`;
        }
        return "";
    }
    headWordy(fuzzyAmount, frontmatterString) {
        return this.wordyString(this.headLine, fuzzyAmount, frontmatterString);
    }
    anchorWordy(fuzzyAmount, frontmatterString) {
        return this.wordyString(this.anchorLine, fuzzyAmount, frontmatterString);
    }
}

function frontmatter(doc, settings) {
    if (!settings.wordyDisplay || !settings.excludeFrontmatter)
        return null;
    const result = doc.toString().match(FRONTMATTER);
    return result ? doc.lineAt(result[0].length).number : null;
}
function getCursorSeparator(settings) {
    let separator = settings.cursorSeparatorOption == "custom"
        ? settings.cursorSeparator
        : CURSORSEPERATOR.get(settings.cursorSeparatorOption);
    separator.trim();
    return ` ${separator} `;
}
function getRangeSeparator(settings) {
    return settings.rangeSeparatorOption == "custom"
        ? settings.rangeSeparator
        : RANGESEPERATOR.get(settings.rangeSeparatorOption);
}
function getDisplayPattern(settings) {
    return settings.displayPatternOption == "custom"
        ? settings.displayPattern
        : DISPLAYPATTERN.get(settings.displayPatternOption);
}
class EditorPlugin {
    constructor(view) {
        this.view = view;
        this.hasPlugin = false;
    }
    calculateWidth(display, updateFont = true) {
        const statusBar = this.plugin.cursorStatusBar;
        if (!this.canvasContext) {
            const canvas = statusBar.createEl("canvas");
            // @ts-ignore
            this.canvasContext = canvas.getContext("2d");
        }
        if (updateFont) {
            const fontWeight = statusBar.getCssPropertyValue("font-weight") || "normal";
            const fontSize = statusBar.getCssPropertyValue("font-size") || "12pt";
            const fontFamily = statusBar.getCssPropertyValue("font-family") || "ui-sans-serif";
            const font = `${fontWeight} ${fontSize} ${fontFamily}`;
            this.canvasContext.font = font;
        }
        const metrics = this.canvasContext.measureText(display);
        const pad = parseInt(statusBar.getCssPropertyValue("padding-right").replace("px", ""));
        const width = Math.floor(metrics.width + pad + pad);
        return width;
    }
    update() {
        if (!this.hasPlugin || !this.plugin.showUpdates)
            return;
        const settings = this.plugin.settings;
        const state = this.view.state;
        const docLines = state.doc.lines;
        let display;
        const fmLine = frontmatter(state.doc, settings);
        let selections = generateSelections(state.doc, state.selection.ranges, fmLine);
        let cursors = selections.cursors;
        if (settings.wordyDisplay) {
            if (cursors.length == 1) {
                display = this.wordyDisplay(cursors[0]);
            }
            else if (cursors.length <= settings.numberCursors) {
                let cursorStrings = [];
                cursors.forEach((cursor) => {
                    cursorStrings.push(this.wordyDisplay(cursor, true));
                });
                const separator = getCursorSeparator(settings);
                display = cursorStrings.join(separator);
            }
            else {
                display = format(MULTCURSORS, cursors.length);
            }
        }
        else {
            if (cursors && settings.numberCursors) {
                if (cursors.length == 1) {
                    display = this.rowColDisplay(cursors[0]);
                }
                else if (cursors.length <= settings.numberCursors) {
                    let cursorStrings = [];
                    cursors.forEach((value) => {
                        cursorStrings.push(this.rowColDisplay(value, true, true));
                    });
                    const separator = getCursorSeparator(settings);
                    display = cursorStrings.join(separator);
                    if (/ct/.test(getDisplayPattern(settings))) {
                        display += separator + docLines;
                    }
                }
                else {
                    display = format(MULTCURSORS, cursors.length);
                }
                if (selections.chars != 0) {
                    display += selections.totalDisplay(settings);
                }
                if (settings.statusBarPadding) {
                    const step = settings.paddingStepOption == "custom"
                        ? settings.paddingStep
                        : PADDINGSTEP.get(settings.paddingStepOption);
                    const width = this.calculateWidth(display);
                    let padWidth = Math.ceil(width / step) * step;
                    if (width == padWidth)
                        padWidth += Math.ceil(step / 3);
                    this.plugin.cursorStatusBar.setAttribute("style", `justify-content:right;width:${padWidth}px;`);
                }
                else {
                    this.plugin.cursorStatusBar.removeAttribute("style");
                }
            }
        }
        this.plugin.cursorStatusBar.setText(display);
    }
    addPlugin(plugin) {
        this.plugin = plugin;
        this.hasPlugin = true;
        this.update();
    }
    destroy() { }
    rowColDisplay(selection, displayLines = false, skipTotal = false) {
        let value;
        const settings = this.plugin.settings;
        const displayPattern = getDisplayPattern(settings);
        if (settings.selectionMode == "begin") {
            value = selection.anchorString(displayPattern, skipTotal);
        }
        else if (settings.selectionMode == "end") {
            value = selection.headString(displayPattern, skipTotal);
        }
        else if (selection.highlightedChars == 0) {
            value = selection.headString(displayPattern, skipTotal);
        }
        else {
            value =
                selection.anchorString(displayPattern, true) +
                    getRangeSeparator(settings) +
                    selection.headString(displayPattern, skipTotal);
        }
        if (displayLines && settings.displayCursorLines) {
            let numberLines = Math.abs(selection.anchorLine - selection.headLine) + 1;
            let cursorLinePattern = settings.cursorLinePattern;
            value += ` ${cursorLinePattern.replace("lc", numberLines.toString())}`;
        }
        return value;
    }
    wordyDisplay(cursor, displayLines = false) {
        let value;
        const settings = this.plugin.settings;
        const frontmatterString = settings.frontmatterString == "custom" ?
            settings.frontmatterStringCustom :
            settings.frontmatterString;
        if (settings.selectionMode == "begin") {
            value = cursor.anchorWordy(settings.fuzzyAmount, frontmatterString);
        }
        else if (settings.selectionMode == "end") {
            value = cursor.headWordy(settings.fuzzyAmount, frontmatterString);
        }
        else if (cursor.highlightedChars == 0) {
            value = cursor.headWordy(settings.fuzzyAmount, frontmatterString);
        }
        else {
            value =
                cursor.anchorWordy(settings.fuzzyAmount, frontmatterString) +
                    getRangeSeparator(settings) +
                    cursor.headWordy(settings.fuzzyAmount, frontmatterString);
        }
        if (displayLines && settings.displayCursorLines) {
            let numberLines = Math.abs(cursor.anchorLine - cursor.headLine) + 1;
            let cursorLinePattern = settings.cursorLinePattern;
            value += ` ${cursorLinePattern.replace("lc", numberLines.toString())}`;
        }
        return value;
    }
}
const editorPlugin = view.ViewPlugin.fromClass(EditorPlugin);

class CursorLocation extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.cursorStatusBar = null;
        this.showUpdates = true;
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("loading Cursor Location plugin");
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
            this.addSettingTab(new CursorLocationSettingTab(this.app, this));
            this.cursorStatusBar = this.addStatusBarItem();
            this.registerEditorExtension(editorPlugin);
            this.app.workspace.onLayoutReady(() => {
                this.giveEditorPlugin(this.app.workspace.getMostRecentLeaf());
                this.updateShowStatus();
            });
            this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => __awaiter(this, void 0, void 0, function* () {
                this.giveEditorPlugin(leaf);
                this.updateShowStatus();
            })));
            this.registerEvent(this.app.workspace.on("layout-change", () => {
                this.updateShowStatus();
            }));
        });
    }
    updateShowStatus() {
        var _a, _b;
        const mode = (_b = (_a = this.app.workspace.getActiveViewOfType(obsidian.View)) === null || _a === void 0 ? void 0 : _a.getState()) === null || _b === void 0 ? void 0 : _b.mode;
        this.showUpdates = mode == "source";
        if (!this.showUpdates) {
            this.cursorStatusBar.setText("");
            this.cursorStatusBar.removeAttribute("style");
        }
    }
    onunload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("unloading Cursor Location plugin");
            this.cursorStatusBar = null;
        });
    }
    giveEditorPlugin(leaf) {
        var _a;
        // @ts-expect-error
        const editor = (_a = leaf === null || leaf === void 0 ? void 0 : leaf.view) === null || _a === void 0 ? void 0 : _a.editor;
        if (editor) {
            const editorView = editor.cm;
            const editorPlug = editorView.plugin(editorPlugin);
            editorPlug.addPlugin(this);
            editorPlug.update();
        }
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}

module.exports = CursorLocation;


/* nosourcemap */