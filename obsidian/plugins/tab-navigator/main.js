/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TabSwitcher
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/model/SearchModel.svelte
var import_obsidian = require("obsidian");
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i].leaf;
  child_ctx[31] = list[i].titleOrName;
  child_ctx[32] = list[i].aliases;
  child_ctx[33] = list[i].details;
  child_ctx[34] = list[i].tags;
  child_ctx[35] = list[i].extention;
  child_ctx[36] = list[i].matches;
  child_ctx[38] = i;
  return child_ctx;
}
function create_else_block(ctx) {
  var _a, _b, _c, _d;
  let div2;
  let div1;
  let div0;
  let span0;
  let raw0_value = ((_b = (_a = (0, import_obsidian.getIcon)(
    /*leaf*/
    ctx[30].getIcon()
  )) == null ? void 0 : _a.outerHTML) != null ? _b : "") + "";
  let t0;
  let span1;
  let raw1_value = highlightMatches(
    "titleOrName",
    /*titleOrName*/
    ctx[31],
    /*matches*/
    ctx[36]
  ) + "";
  let t1;
  let t2;
  let t3;
  let div2_class_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*settings*/
    ((_c = ctx[0]) == null ? void 0 : _c.enableAliasSearch) && /*aliases*/
    ctx[32].length > 0 && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*settings*/
    ((_d = ctx[0]) == null ? void 0 : _d.enableTagSearch) && /*tags*/
    ctx[34].length > 0 && create_if_block_3(ctx)
  );
  function mouseenter_handler_1() {
    return (
      /*mouseenter_handler_1*/
      ctx[17](
        /*index*/
        ctx[38]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[18](
        /*index*/
        ctx[38]
      )
    );
  }
  function keydown_handler_1(...args) {
    return (
      /*keydown_handler_1*/
      ctx[19](
        /*index*/
        ctx[38],
        ...args
      )
    );
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      attr(span0, "class", "qsp-path-indicator");
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-content");
      attr(div2, "class", div2_class_value = "suggestion-item mod-complex " + /*index*/
      (ctx[38] === /*selectedIndex*/
      ctx[4] ? "is-selected" : ""));
      attr(div2, "tabindex", "0");
      attr(div2, "role", "button");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, span0);
      span0.innerHTML = raw0_value;
      append(div0, t0);
      append(div0, span1);
      span1.innerHTML = raw1_value;
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t3);
      if (!mounted) {
        dispose = [
          listen(div2, "mouseenter", mouseenter_handler_1),
          listen(div2, "click", click_handler_1),
          listen(div2, "keydown", keydown_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2;
      ctx = new_ctx;
      if (dirty[0] & /*searchResults*/
      8 && raw0_value !== (raw0_value = ((_b2 = (_a2 = (0, import_obsidian.getIcon)(
        /*leaf*/
        ctx[30].getIcon()
      )) == null ? void 0 : _a2.outerHTML) != null ? _b2 : "") + ""))
        span0.innerHTML = raw0_value;
      ;
      if (dirty[0] & /*searchResults*/
      8 && raw1_value !== (raw1_value = highlightMatches(
        "titleOrName",
        /*titleOrName*/
        ctx[31],
        /*matches*/
        ctx[36]
      ) + ""))
        span1.innerHTML = raw1_value;
      ;
      if (
        /*settings*/
        ((_c2 = ctx[0]) == null ? void 0 : _c2.enableAliasSearch) && /*aliases*/
        ctx[32].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_4(ctx);
          if_block0.c();
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*settings*/
        ((_d2 = ctx[0]) == null ? void 0 : _d2.enableTagSearch) && /*tags*/
        ctx[34].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_3(ctx);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*selectedIndex*/
      16 && div2_class_value !== (div2_class_value = "suggestion-item mod-complex " + /*index*/
      (ctx[38] === /*selectedIndex*/
      ctx[4] ? "is-selected" : ""))) {
        attr(div2, "class", div2_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  var _a, _b, _c, _d;
  let div3;
  let div2;
  let div0;
  let span0;
  let raw0_value = highlightMatches(
    "titleOrName",
    /*titleOrName*/
    ctx[31],
    /*matches*/
    ctx[36]
  ) + "";
  let t0;
  let t1;
  let t2;
  let div1;
  let span1;
  let raw1_value = ((_b = (_a = (0, import_obsidian.getIcon)(
    /*leaf*/
    ctx[30].getIcon()
  )) == null ? void 0 : _a.outerHTML) != null ? _b : "") + "";
  let t3;
  let span2;
  let raw2_value = highlightMatches(
    "details",
    /*details*/
    ctx[33],
    /*matches*/
    ctx[36]
  ) + "";
  let t4;
  let div3_class_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*settings*/
    ((_c = ctx[0]) == null ? void 0 : _c.enableAliasSearch) && /*aliases*/
    ctx[32].length > 0 && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*settings*/
    ((_d = ctx[0]) == null ? void 0 : _d.enableTagSearch) && create_if_block_1(ctx)
  );
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[14](
        /*index*/
        ctx[38]
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*index*/
        ctx[38]
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[16](
        /*index*/
        ctx[38],
        ...args
      )
    );
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      span1 = element("span");
      t3 = space();
      span2 = element("span");
      t4 = space();
      attr(div0, "class", "suggestion-title");
      attr(span1, "class", "qsp-path-indicator");
      attr(span2, "class", "qsp-path");
      attr(div1, "class", "suggestion-note qsp-note");
      attr(div2, "class", "suggestion-content");
      attr(div3, "class", div3_class_value = "suggestion-item mod-complex " + /*index*/
      (ctx[38] === /*selectedIndex*/
      ctx[4] ? "is-selected" : ""));
      attr(div3, "tabindex", "0");
      attr(div3, "role", "button");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, span0);
      span0.innerHTML = raw0_value;
      append(div0, t0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t2);
      append(div2, div1);
      append(div1, span1);
      span1.innerHTML = raw1_value;
      append(div1, t3);
      append(div1, span2);
      span2.innerHTML = raw2_value;
      append(div3, t4);
      if (!mounted) {
        dispose = [
          listen(div3, "mouseenter", mouseenter_handler),
          listen(div3, "click", click_handler),
          listen(div3, "keydown", keydown_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2;
      ctx = new_ctx;
      if (dirty[0] & /*searchResults*/
      8 && raw0_value !== (raw0_value = highlightMatches(
        "titleOrName",
        /*titleOrName*/
        ctx[31],
        /*matches*/
        ctx[36]
      ) + ""))
        span0.innerHTML = raw0_value;
      ;
      if (
        /*settings*/
        ((_a2 = ctx[0]) == null ? void 0 : _a2.enableAliasSearch) && /*aliases*/
        ctx[32].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_2(ctx);
          if_block0.c();
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*settings*/
        (_b2 = ctx[0]) == null ? void 0 : _b2.enableTagSearch
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_1(ctx);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*searchResults*/
      8 && raw1_value !== (raw1_value = ((_d2 = (_c2 = (0, import_obsidian.getIcon)(
        /*leaf*/
        ctx[30].getIcon()
      )) == null ? void 0 : _c2.outerHTML) != null ? _d2 : "") + ""))
        span1.innerHTML = raw1_value;
      ;
      if (dirty[0] & /*searchResults*/
      8 && raw2_value !== (raw2_value = highlightMatches(
        "details",
        /*details*/
        ctx[33],
        /*matches*/
        ctx[36]
      ) + ""))
        span2.innerHTML = raw2_value;
      ;
      if (dirty[0] & /*selectedIndex*/
      16 && div3_class_value !== (div3_class_value = "suggestion-item mod-complex " + /*index*/
      (ctx[38] === /*selectedIndex*/
      ctx[4] ? "is-selected" : ""))) {
        attr(div3, "class", div3_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4(ctx) {
  let span1;
  let t_value = " ";
  let t;
  let span0;
  let raw_value = highlightMatches(
    "aliases",
    /*aliases*/
    ctx[32],
    /*matches*/
    ctx[36]
  ) + "";
  return {
    c() {
      span1 = element("span");
      t = text(t_value);
      span0 = element("span");
      attr(span0, "class", "alias");
      attr(span1, "class", "suggestion-note qsp-note");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t);
      append(span1, span0);
      span0.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchResults*/
      8 && raw_value !== (raw_value = highlightMatches(
        "aliases",
        /*aliases*/
        ctx2[32],
        /*matches*/
        ctx2[36]
      ) + ""))
        span0.innerHTML = raw_value;
      ;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
    }
  };
}
function create_if_block_3(ctx) {
  let span1;
  let t_value = " ";
  let t;
  let span0;
  let raw_value = highlightMatches(
    "tags",
    /*tags*/
    ctx[34],
    /*matches*/
    ctx[36]
  ) + "";
  return {
    c() {
      span1 = element("span");
      t = text(t_value);
      span0 = element("span");
      attr(span0, "class", "tag");
      attr(span1, "class", "suggestion-note qsp-note");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t);
      append(span1, span0);
      span0.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchResults*/
      8 && raw_value !== (raw_value = highlightMatches(
        "tags",
        /*tags*/
        ctx2[34],
        /*matches*/
        ctx2[36]
      ) + ""))
        span0.innerHTML = raw_value;
      ;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let span1;
  let t_value = " ";
  let t;
  let span0;
  let raw_value = highlightMatches(
    "aliases",
    /*aliases*/
    ctx[32],
    /*matches*/
    ctx[36]
  ) + "";
  return {
    c() {
      span1 = element("span");
      t = text(t_value);
      span0 = element("span");
      attr(span0, "class", "alias");
      attr(span1, "class", "suggestion-note qsp-note");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t);
      append(span1, span0);
      span0.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchResults*/
      8 && raw_value !== (raw_value = highlightMatches(
        "aliases",
        /*aliases*/
        ctx2[32],
        /*matches*/
        ctx2[36]
      ) + ""))
        span0.innerHTML = raw_value;
      ;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let span1;
  let t_value = " ";
  let t;
  let span0;
  let raw_value = highlightMatches(
    "tags",
    /*tags*/
    ctx[34],
    /*matches*/
    ctx[36]
  ) + "";
  return {
    c() {
      span1 = element("span");
      t = text(t_value);
      span0 = element("span");
      attr(span0, "class", "tag");
      attr(span1, "class", "suggestion-note qsp-note");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t);
      append(span1, span0);
      span0.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchResults*/
      8 && raw_value !== (raw_value = highlightMatches(
        "tags",
        /*tags*/
        ctx2[34],
        /*matches*/
        ctx2[36]
      ) + ""))
        span0.innerHTML = raw_value;
      ;
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
    }
  };
}
function create_each_block(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    var _a;
    if (
      /*settings*/
      (_a = ctx2[0]) == null ? void 0 : _a.showFilePath
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let div11;
  let div0;
  let t0;
  let div10;
  let div2;
  let input;
  let t1;
  let div1;
  let t2;
  let div3;
  let t3;
  let div9;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*searchResults*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div11 = element("div");
      div0 = element("div");
      t0 = space();
      div10 = element("div");
      div2 = element("div");
      input = element("input");
      t1 = space();
      div1 = element("div");
      t2 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div9 = element("div");
      div9.innerHTML = `<div class="prompt-instruction"><span class="prompt-instruction-command">\u2191\u2193</span><span>to navigate</span></div> <div class="prompt-instruction"><span class="prompt-instruction-command">\u21B5</span><span>to open</span></div> <div class="prompt-instruction"><span class="prompt-instruction-command">\u21E5</span><span>to close</span></div> <div class="prompt-instruction"><span class="prompt-instruction-command">\u21E7 \u21E5</span><span>to close duplicate</span></div> <div class="prompt-instruction"><span class="prompt-instruction-command">esc</span><span>to exit</span></div>`;
      attr(div0, "class", "modal-bg");
      set_style(div0, "opacity", "0.85");
      attr(input, "class", "prompt-input");
      attr(input, "enterkeyhint", "done");
      attr(input, "type", "text");
      attr(input, "placeholder", "Find a note...");
      attr(div1, "class", "prompt-input-cta");
      attr(div2, "class", "prompt-input-container");
      attr(div3, "class", "prompt-results");
      attr(div9, "class", "prompt-instructions");
      attr(div9, "data-mode", "standard");
      attr(div10, "class", "prompt");
      attr(div11, "class", "modal-container mod-dim");
    },
    m(target, anchor) {
      insert(target, div11, anchor);
      append(div11, div0);
      append(div11, t0);
      append(div11, div10);
      append(div10, div2);
      append(div2, input);
      ctx[11](input);
      set_input_value(
        input,
        /*searchInput*/
        ctx[2]
      );
      append(div2, t1);
      append(div2, div1);
      append(div10, t2);
      append(div10, div3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div3, null);
        }
      }
      append(div10, t3);
      append(div10, div9);
      ctx[20](div10);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[12]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchInput*/
      4 && input.value !== /*searchInput*/
      ctx2[2]) {
        set_input_value(
          input,
          /*searchInput*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*selectedIndex, selectItem, searchResults, settings*/
      153) {
        each_value = ensure_array_like(
          /*searchResults*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div3, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div11);
      }
      ctx[11](null);
      destroy_each(each_blocks, detaching);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function highlightMatches(key, text2, matches) {
  if (!matches)
    return text2;
  const match = matches.find((m) => m.key === key);
  if (!match)
    return text2;
  let highlightedText = text2;
  match.indices.slice().reverse().forEach(([start, end]) => {
    const before = highlightedText.substring(0, start);
    const matchText = highlightedText.substring(start, end + 1);
    const after = highlightedText.substring(end + 1);
    highlightedText = `${before}<span class="suggestion-highlight">${matchText}</span>${after}`;
  });
  return highlightedText;
}
function instance($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { currentWindow } = $$props;
  let { removeDuplicateTabs } = $$props;
  let { settings } = $$props;
  const dispatch = createEventDispatcher();
  let modalContainer;
  let searchInput = "";
  let allLeaves = [];
  let searchResults = [];
  let selectedIndex = 0;
  let currentLeafIndex = 0;
  let inputElement;
  let fuse;
  onMount(() => {
    function handleClickOutside(event) {
      const path = event.composedPath();
      if (!path.includes(modalContainer)) {
        dispatch("close");
      }
    }
    currentWindow.document.addEventListener("click", handleClickOutside);
    loadLeaves();
    setCurrentLeafIndex();
    currentWindow.addEventListener("keydown", handleKeyDown);
    if (inputElement) {
      inputElement.focus();
    }
    return () => {
      currentWindow.document.removeEventListener("click", handleClickOutside);
      currentWindow.removeEventListener("keydown", handleKeyDown);
    };
  });
  function setCurrentLeafIndex() {
    const activeLeaf = app.workspace.activeLeaf;
    currentLeafIndex = allLeaves.findIndex((leaf) => leaf.leaf === activeLeaf);
    $$invalidate(4, selectedIndex = currentLeafIndex >= 0 ? currentLeafIndex : 0);
  }
  function loadLeaves() {
    return __awaiter(this, void 0, void 0, function* () {
      allLeaves = [];
      app.workspace.iterateAllLeaves((leaf) => {
        var _a, _b, _c, _d;
        if (!(leaf.view instanceof import_obsidian.FileView && !["backlink", "outline", "tag", "outgoing-link"].includes(leaf.getViewState().type))) {
          return;
        }
        let titleOrName;
        let details;
        let aliases = "";
        let tags = "";
        let extention = null;
        if (leaf.view instanceof import_obsidian.FileView) {
          const file = leaf.view.file;
          titleOrName = file.basename;
          if (settings === null || settings === void 0 ? void 0 : settings.includeFileNameInPath) {
            details = file.path;
          } else {
            details = (_b = (_a = file.parent) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : "";
          }
          extention = file.extension;
          if (extention !== "md") {
            titleOrName += "." + extention;
          }
          if (settings === null || settings === void 0 ? void 0 : settings.enableAliasSearch) {
            const fileCache = app.metadataCache.getFileCache(file);
            if (((_c = fileCache === null || fileCache === void 0 ? void 0 : fileCache.frontmatter) === null || _c === void 0 ? void 0 : _c.aliases) && fileCache.frontmatter.aliases.length > 0) {
              aliases = "@" + fileCache.frontmatter.aliases.join(" @");
            }
          }
          if (settings === null || settings === void 0 ? void 0 : settings.enableTagSearch) {
            const fileCache = app.metadataCache.getFileCache(file);
            if ((_d = fileCache === null || fileCache === void 0 ? void 0 : fileCache.frontmatter) === null || _d === void 0 ? void 0 : _d.tags) {
              tags = "#" + fileCache.frontmatter.tags.join(" #");
            }
          }
        } else {
          titleOrName = leaf.view.getViewType().replace(/_/g, " ").replace(/^\w/, (c) => c.toUpperCase());
          details = ":" + leaf.view.getViewType();
        }
        allLeaves.push({
          leaf,
          titleOrName,
          aliases,
          tags,
          details,
          extention,
          matches: void 0
        });
      });
      $$invalidate(3, searchResults = allLeaves);
      const keys = ["titleOrName"];
      if (settings === null || settings === void 0 ? void 0 : settings.showFilePath) {
        keys.push("details");
      }
      if (settings === null || settings === void 0 ? void 0 : settings.enableAliasSearch) {
        keys.push("aliases");
      }
      if (settings === null || settings === void 0 ? void 0 : settings.enableTagSearch) {
        keys.push("tags");
      }
      const options = {
        includeScore: true,
        includeMatches: true,
        keys
      };
      fuse = new Fuse(allLeaves, options);
    });
  }
  function handleInput(event) {
    const inputElement2 = event.currentTarget;
    $$invalidate(2, searchInput = inputElement2.value);
    filterSearchResults();
  }
  function filterSearchResults() {
    if (searchInput.trim() === "") {
      $$invalidate(3, searchResults = allLeaves);
      $$invalidate(4, selectedIndex = currentLeafIndex >= 0 ? currentLeafIndex : 0);
    } else {
      $$invalidate(3, searchResults = fuse.search(searchInput).map((result) => {
        console.log(result);
        return Object.assign(Object.assign({}, result.item), { matches: result.matches });
      }));
    }
    $$invalidate(4, selectedIndex = 0);
  }
  function handleKeyDown(event) {
    if (event.key === "ArrowDown" || event.key === "n" && event.ctrlKey) {
      $$invalidate(4, selectedIndex = (selectedIndex + 1) % searchResults.length);
      event.preventDefault();
    } else if (event.key === "ArrowUp" || event.key === "p" && event.ctrlKey) {
      $$invalidate(4, selectedIndex = (selectedIndex - 1 + searchResults.length) % searchResults.length);
      event.preventDefault();
    } else if (event.key === "Enter" && !event.isComposing) {
      selectItem(selectedIndex);
    } else if (event.key === "Escape") {
      dispatch("close");
    } else if (event.key === "Tab" && event.shiftKey) {
      event.preventDefault();
      removeDuplicateTabs();
      loadLeaves();
      filterSearchResults();
    } else if (event.key === "Tab") {
      event.preventDefault();
      const prevIndex = selectedIndex;
      removeTab(selectedIndex);
      loadLeaves();
      filterSearchResults();
      if (searchResults.length == 0) {
        dispatch("close");
      }
      $$invalidate(4, selectedIndex = Math.min(prevIndex, searchResults.length - 1));
    }
  }
  function selectItem(index) {
    const selectedItem = searchResults[index];
    const leaf = selectedItem.leaf;
    app.workspace.setActiveLeaf(leaf, { focus: true });
    setTimeout(
      () => {
        dispatch("close");
      },
      100
    );
  }
  function removeTab(index) {
    searchResults[index].leaf.detach();
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(5, inputElement);
    });
  }
  function input_input_handler() {
    searchInput = this.value;
    $$invalidate(2, searchInput);
  }
  const input_handler = (event) => handleInput(event);
  const mouseenter_handler = (index) => $$invalidate(4, selectedIndex = index);
  const click_handler = (index) => selectItem(index);
  const keydown_handler = (index, event) => event.key === "Enter" && selectItem(index);
  const mouseenter_handler_1 = (index) => $$invalidate(4, selectedIndex = index);
  const click_handler_1 = (index) => selectItem(index);
  const keydown_handler_1 = (index, event) => event.key === "Enter" && selectItem(index);
  function div10_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalContainer = $$value;
      $$invalidate(1, modalContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(8, app = $$props2.app);
    if ("currentWindow" in $$props2)
      $$invalidate(9, currentWindow = $$props2.currentWindow);
    if ("removeDuplicateTabs" in $$props2)
      $$invalidate(10, removeDuplicateTabs = $$props2.removeDuplicateTabs);
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  return [
    settings,
    modalContainer,
    searchInput,
    searchResults,
    selectedIndex,
    inputElement,
    handleInput,
    selectItem,
    app,
    currentWindow,
    removeDuplicateTabs,
    input_binding,
    input_input_handler,
    input_handler,
    mouseenter_handler,
    click_handler,
    keydown_handler,
    mouseenter_handler_1,
    click_handler_1,
    keydown_handler_1,
    div10_binding
  ];
}
var SearchModel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        app: 8,
        currentWindow: 9,
        removeDuplicateTabs: 10,
        settings: 0
      },
      null,
      [-1, -1]
    );
  }
};
var SearchModel_default = SearchModel;

// src/setting.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  showFilePath: true,
  includeFileNameInPath: true,
  enableTagSearch: true,
  enableAliasSearch: true,
  loadAllTabsOnStartup: false
};
var TabNavigatorSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    const settings = this.plugin.settings;
    if (settings) {
      new import_obsidian2.Setting(containerEl).setName("Show File Path").setDesc("Show the file path in the search results.").addToggle(
        (toggle) => toggle.setValue(settings.showFilePath).onChange((value) => {
          settings.showFilePath = value;
          this.plugin.saveSettings();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Include File Name in Path (if show file path is enabled)").setDesc("Include the file name in the file path.").addToggle(
        (toggle) => toggle.setValue(settings.includeFileNameInPath).setDisabled(!settings.showFilePath).onChange((value) => {
          settings.includeFileNameInPath = value;
          this.plugin.saveSettings();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Enable Alias Search").setDesc("Enable or disable the ability to search articles using aliases.").addToggle(
        (toggle) => toggle.setValue(settings.enableAliasSearch).onChange((value) => {
          settings.enableAliasSearch = value;
          this.plugin.saveSettings();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Enable Tag Search").setDesc("Enable or disable the ability to search articles using tags.").addToggle(
        (toggle) => toggle.setValue(settings.enableTagSearch).onChange((value) => {
          settings.enableTagSearch = value;
          this.plugin.saveSettings();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Load all tabs on startup (Experimental)").setDesc(
        "Automatically load all tabs when Obsidian starts. \u26A0\uFE0F This is an experimental feature that might impact startup performance. May not work correctly in all situations."
      ).addToggle(
        (toggle) => toggle.setValue(settings.loadAllTabsOnStartup).onChange(async (value) => {
          settings.loadAllTabsOnStartup = value;
          await this.plugin.saveSettings();
        })
      );
    }
  }
};

// src/main.ts
var TabSwitcher = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.searchModelInstance = null;
    this.settings = null;
  }
  async onload() {
    var _a;
    await this.loadSettings();
    this.addSettingTab(new TabNavigatorSettingTab(this.app, this));
    if ((_a = this.settings) == null ? void 0 : _a.loadAllTabsOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        this.loadAllTabsFromDOM();
      });
    }
    this.addCommand({
      id: "search-tabs",
      name: "Search tabs",
      callback: () => {
        var _a2;
        const { app } = this;
        if (this.searchModelInstance) {
          this.searchModelInstance.$destroy();
          this.searchModelInstance = null;
        }
        const activeView = app.workspace.getActiveViewOfType(import_obsidian3.View);
        const currentWindow = (_a2 = activeView == null ? void 0 : activeView.containerEl.ownerDocument.defaultView) != null ? _a2 : window;
        this.searchModelInstance = new SearchModel_default({
          target: currentWindow.document.body,
          props: {
            app,
            currentWindow,
            settings: this.settings,
            removeDuplicateTabs: this.removeDuplicateTabs.bind(this)
          }
        });
        this.searchModelInstance.$on("close", () => {
          if (this.searchModelInstance) {
            this.searchModelInstance.$destroy();
            this.searchModelInstance = null;
          }
        });
      }
    });
    this.addCommand({
      id: "remove-duplicate-tabs",
      name: "Remove duplicate tabs",
      callback: () => {
        this.removeDuplicateTabs();
      }
    });
    this.addCommand({
      id: "load-all-tabs",
      name: "Load all tabs",
      callback: () => {
        this.loadAllTabsFromDOM();
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Method to remove duplicate tabs
  removeDuplicateTabs() {
    const seen = /* @__PURE__ */ new Set();
    const toRemove = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian3.EditableFileView) {
        const file = leaf.view.file;
        if (file && seen.has(file.path)) {
          toRemove.push(leaf);
        } else if (file) {
          seen.add(file.path);
        }
      } else if (leaf.view.getViewType() === "empty") {
        toRemove.push(leaf);
      }
    });
    toRemove.forEach((leaf) => leaf.detach());
  }
  // Destroy component when plugin is unloaded
  onunload() {
    if (this.searchModelInstance) {
      this.searchModelInstance.$destroy();
    }
  }
  // Method to load all tabs from DOM
  async loadAllTabsFromDOM() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.View);
    const tabHeaders = document.querySelectorAll(".workspace-tab-header");
    for (const header of Array.from(tabHeaders)) {
      const type = header.getAttribute("data-type");
      if (type === "markdown") {
        header.click();
        await new Promise((resolve) => setTimeout(resolve, 25));
      }
    }
    if (activeView == null ? void 0 : activeView.leaf) {
      this.app.workspace.setActiveLeaf(activeView.leaf, { focus: true });
    }
  }
};

/* nosourcemap */